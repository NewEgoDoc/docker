# **컨테이너 기술과 Docker의 개요**


## `1.Container`

일단 컨테이너의 기본 개념을 소개한다. 컨테이너란 호스트 OS상에 논리적인 구획을 만들고, 애플리케이션을 작동시키기 위해 필요한 라이브러리나 애플리케이션 등을 하나로 모아, 마치 별도의 서버인 것처럼 사용할 수 있게 만든 것이다. 호스트 OS의 리소스를 논리적으로 분리시키고, 여러개의 컨테이너가 공유하여 사용한다. 컨테이너는 오버헤드가 적기 때문에 가볍고 고속으로 작동한다는 것이 특징이다.

이게 도대체 무슨소리인지...

하지만 컨테이너가 가진 장점을 함축적으로 아주 논리있게 정리해놓은 말이다.

그럼 이제 내식으로 간단하게 정리해보자.
컨테이너란 우리가 생각하는 하나의 애플리케이션이다. 그저 구조가 다른것이다.
그럼 그 구조가 어떻게 다르냐? 
우리가 웹 어플리케이션을 만들때는 코드를 생성하고 배포까지 꽤 복잡한 과정을 걸친다. 일단 굉장히 무거운 서버컴퓨터가 필요하고 해당 서버컴퓨터에 OS(운영체제)가 필요하며 그 위에 필요한 환경 Nodejs라던가 Java라는 언어를 올려서 javac(컴파일러)를 다운받아 어느정도 돌아가게 하려면 spring (boot)까지 여러 의존성을 구축해주어야 비로소 하나의 어플리케이션이 배포될 환경'만' 조성된것이다. 실제 해당과정까지 적어도 2,3시간은 기본이다. 이렇게 인프라가 구축되기까지 굉장히 많은 시간이 걸리고 비용도 많이 들지만 container는 다르다.
컨테이너는 필요한 이미지를 다운받고 리눅스 커널의 도움으로 인프라도 세세하게 구별시킬수 있다. 단축키 몇개만으로 컨테이너 이미지를 다운받거나 구성할수 있으며 dockerfile이나 yaml또는 yml 파일이 있으면 예약어 한방에 이미지를 다운받고 컨테이너화가 가능하다. 이렇게 만들어진 컨테이너는 다시 이미지화 시켜서 여러개의 컨테이너를 실행시킬수 있는데 웹어플리케이션의 경우 우리는 하나의 서버가 다운되도 다른 여러개의 동일한 어플리케이션의 컨테이너가 버텨주고 있기 때문에 완전히 서버가 내려가는 것을 방지 할수 있는 것이다.

보통 물리 서버상에 설치한 호스트 OS의 경우 하나의 OS사에서 움직이는 여러 애플리케이션은 똑같은 시스템 리소스를 사용한다. 이때 작동하는 여러 애플리케이션은 데이터를 저장하는 디렉토리를 공유하고(이걸 볼륨 마운트라고 하는데 이후에 알아보자), 서버에 설정된 동일한 IP주소로 통신을 한다. 그래서 여러 애플리케이션에서 사용하고 있는 미들웨어나 라이브러리 버전이 다른 경우에는 각 애플리케이션이 서로 영향을 받지 않도록 주의해야한다.

이에 반해 컨테이너 기술을 사용하면 OS나 디렉토리 IP주소등과 같은 시스템 자원을 각 애플리케이션이 점유하고 있는 것 '처럼' 보이게 할 수 있다.

컨테이너는 애플리케이션의 실행에 필요한 모듈을 컨테이너로 모을 수 있기 때문에 여러 개의 컨테이너를 조합하여 하나의 애플리케이션을 구축하는 MSA과 친화성이 높다.

### **- ㅁㄴㅇㄻㄴㅇㄹ**


## `2. Dokcer의 개요`

Docker는 애플리케이션의 실행에 필요한 환경을 하나의 이미지로 모아두고, 그 이미지를 사용하여 다양한 환경에서 애플리케이션 실행 환경을 구축 및 운용하기 위한 오픈소스 플랫폼이다.
앞서 말했듯이 도커 내부에서는 컨테이너 기술을 사용하고 있다.

**---------**

## `3. Dokcer의 기능`

Docker의 구체적인 기능은 크게 세가지가 있다:
* Docker 이미지를 만드는 기능(Build)
* Docker 이미지를 공유하는 기능(Ship)
* Docker 컨테이너를 작동시키는 기능(Run)

### **- Docker 이미지를 만드는 기능(Build)**


Docker는 애플리케이션의 실행에 필요한 프로그램 본체, 라이브러리, 미들웨어, OS나 네트워크 설정등을 하나로 모아서 Docker 이미지를 만든다.

Docker 이미지는 실행환경에서 움직이는 컨테이너의 바탕이 된다.

Docker에서는 하나의 이미지에는 하나의 애플리케이션만 넣어두고, 여러개의 컨테이너를 조합하여 서비스를 구축하는 방법을 권장하고 있다.

Docker 이미지는 Docker의 명령을 사용하여 수동으로 만들 수 있으며 *Dockerfile*이라는 설정 파일을 만들어 그것을 바탕으로 자동으로 이미지를 만들 수 있다.

<!--
```html
import React from 'react';
import Hello from './Hello';

function App() {
  return (
    <>
      <Hello />
      <div>안녕히계세요</div>
    </>
  );
}

export default App;
```

**style과 className**

JSX에서 태그에 style 과 CSS class를 설정하는 방법은 HTML에서 설정하는 방법과 아주작은 차이가 있다. 그것은 class 키워드 때문에 생겨난 것인데 class 해당내용에서 말그대로 class변수로서 사용되기때문에 우리는 className 이라는 속성을 사용하여 css를 지정해 줄 수 있으며 background-Color 같은 구분자보다 CamelCase 형태로 네이밍 해주어야한다.


**주석**

주석은`{/* 이런 형식으로 */}` 추가해준다.
-->

## `3.Props`
<!-- Line -->
___

<!-- Text attributes -->
Builds the **app** for production to the `build` folder.\
It correctly bundles *React* in production mode and ~~optimizes~~ the build for the best performance.
<!-- Quote -->
>The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!
<!-- Bullet list -->
목록만들기:
* 목록1
* 목록2